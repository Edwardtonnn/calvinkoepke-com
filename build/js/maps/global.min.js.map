{"version":3,"sources":["global.js"],"names":["stickify","selector","el","document","querySelector","elTop","getOffset","window","addEventListener","top","checkStickify","triggerScroll","offsetTarget","stickifyElement","classList","contains","unStickifyElement","elWidth","getBoundingClientRect","add","width","setAttribute","left","scrollY","event","MouseEvent","view","bubbles","cancelable","dispatchEvent","ref","getElementsByTagName","script","createElement","async","src","parentNode","insertBefore","cb","onload","loaded","Promise","resolve","readyState","ready","then","loadJS","nav","insertAdjacentHTML"],"mappings":"cAMA,WA4DC,QAASA,GAASC,GAEjB,GAAIC,GAAQC,SAASC,cAAcH,GAAnCI,EACCA,EAAQC,GAAUJ,GAGnBK,QAAOC,iBAAiB,SAAU,WACjCH,EAAQC,EAAUJ,GAAIO,IACtBC,EAAcR,EAAIG,KAInBE,OAAOC,iBAAiB,SAAU,WACjCE,EAAcR,EAAIG,KAInBF,SAASK,iBAAiB,mBAAoBG,KAS/C,QAASD,GAAcR,EAAIU,GAGzBC,OAAAA,QAAAD,IAAAV,EAAAY,UAAAC,SAAA,aACAF,EAAAX,GAGAc,OAAAA,QAAAJ,GAAAV,EAAAY,UAAAC,SAAA,aACAC,EAAAd,GASD,QAAIe,GAAaC,GACjBhB,GAAGY,GAAUK,EAAID,wBAAjBE,KACAlB,GAAGmB,UAAAA,IAAa,YAChBnB,EAAAmB,aAAA,QAAA,UAAAJ,EAAA,eAQAf,QAAGY,GAAiBZ,GACpBA,EAAGmB,UAAAA,OAAa,YAChBnB,EAAAmB,aAAA,QAAA,IASAnB,QAAQgB,GAAAA,GAEPI,MADDpB,GAAAA,EAAOgB,yBAENT,KAAKP,EAAGO,KAAMF,OAAOgB,QAFtBd,IAAAP,EAAAO,IAAAF,OAAAgB,SAYA,QAAIC,KACH,GAAAA,GAAQjB,GAD4BkB,YAAA,UAEpCC,KAAAnB,OACAoB,SAAA,EAHWC,YAAZ,GAMArB,QAAAsB,cAAAL,GAOC,QAAIM,GAAW3B,EAAS4B,GACxB,GAAIC,GAAW7B,SAAS8B,qBAAxB,UAAA,GACAD,EAAA7B,SAAA8B,cAAA,SAOA,OANAD,GAAOE,IAAQC,EACfL,EAAIM,OAAWC,EACfP,EAAIQ,WAAMD,aAAeL,EAAYF,GACpCE,GAAA,kBAAgBM,KAChBN,EAAAO,OAAAD,GAEDN,EA9JF,GAEAQ,GAAA,WAAA,MAAA,IAAAC,SASC,SAAAC,GADc,WAATF,SAASG,YAAAD,QAVf,WAAA,MAAA,IAAAD,SAGC,SAAAC,GADa,YAARE,SAAQD,YAAAD,UAQdG,KAQAD,WAQc,OAHFzC,SAASC,cAAc,aAMjC0C,EAAW,4DAMZN,KAASK,KAAK,WAAdL,EAASK,gBACR7C,EAAS,2BAIV,IAAA+C,GAAA5C,SAAAC,cAAA,eAGA2C,GAAAC,mBAAA,cAAA,2DAGA7C,SAAAC,cAAA,gBAAAI,iBAAA,QAAA,WACAL,EAAAA,UAASC,OAAT","file":"../global.min.js","sourcesContent":["/**\n * JavaScript functions for the theme (no jQuery).\n *\n * @since 2.0.0\n *\n */\n(function() {\n\n\t\"use strict\";\n\n\tconst ready = () => new Promise(\n\t\tresolve => {\n\t\t\tif (document.readyState !== 'loading') {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t}\n\t);\n\n\tconst loaded = () => new Promise(\n\t\tresolve => {\n\t\t\tif (document.readyState === 'loaded') {\n\t\t\t\tresolve();\n\t\t\t}\n\t\t}\n\t);\n\n\tready().then(init());\n\n\tfunction init() {\n\n\t\t// Check for content.\n\t\tvar code = document.querySelector('pre,code');\n\n\t\t// Load the script if there is any pre/code tags.\n\t\tif (code !== null) {\n\n\t\t\t// Prism script.\n\t\t\tvar src  = '/wp-content/themes/calvinkoepke-com/build/js/prism.min.js';\n\n\t\t\tloadJS(src);\n\t\t\t\n\t\t}\n\n\t\tloaded().then(() => {\n\t\t\tstickify('.nav-primary');\n\t\t\tstickify('.sidebar .enews-widget');\n\t\t});\n\n\t\t// Setup mobile menu toggle.\n\t\tvar nav = document.querySelector('.nav-primary');\n\n\t\t// Add toggle button.\n\t\tnav.insertAdjacentHTML('beforeBegin', '<button class=\"button menu-toggle\">Toggle Menu</button>');\n\n\t\t// Setup event handler.\n\t\tdocument.querySelector('.menu-toggle').addEventListener('click', function() {\n\t\t\tnav.classList.toggle('visible');\n\t\t});\n\n\t}\n\n\t/**\n\t * Helper function to make an element sticky on scroll.\n\t * @param  string selector Selector to be used (uses querySelector).\n\t * @since 2.0.0\n\t */\n\tfunction stickify(selector) {\n\n\t\tvar el    = document.querySelector(selector),\n\t\t\telTop = getOffset(el).top;\n\n\t\t// Update values on window resize.\n\t\twindow.addEventListener('resize', function() {\n\t\t\telTop = getOffset(el).top;\n\t\t\tcheckStickify(el, elTop);\n\t\t});\n\n\t\t// Update sticky element on scroll position.\n\t\twindow.addEventListener('scroll', function() {\n\t\t\tcheckStickify(el, elTop);\n\t\t});\n\n\t\t// Trigger scroll event on load.\n\t\tdocument.addEventListener('DOMContentLoaded', triggerScroll());\n\n\t}\n\n\t/**\n\t * Helper function to determine sticky state.\n\t *\n\t * @since 2.0.0\n\t */\n\tfunction checkStickify(el, offsetTarget) {\n\n\t\tif ( window.scrollY > offsetTarget && ! el.classList.contains('stickify') ) {\n\t\t\tstickifyElement(el);\n\t\t}\n\n\t\tif ( window.scrollY < offsetTarget && el.classList.contains('stickify') ) {\n\t\t\tunStickifyElement(el);\n\t\t}\n\t}\n\n\t/**\n\t * Helper function to initiate sticky state.\n\t *\n\t * @since 2.0.0\n\t */\n\tfunction stickifyElement(el) {\n\t\tvar elWidth = el.getBoundingClientRect().width;\n\t\tel.classList.add('stickify');\n\t\tel.setAttribute('style', 'width: ' + elWidth + 'px; top: 0;');\n\t}\n\n\t/**\n\t * Helper function to denitiate sticky state.\n\t *\n\t * @since 2.0.0\n\t */\n\tfunction unStickifyElement(el) {\n\t\tel.classList.remove('stickify');\n\t\tel.setAttribute('style', '');\n\t}\n\n\t/**\n\t * Helper function to get the offset.\n\t * @param  node   el DOM Node to get the offset for.\n\t * @return object    Object containing offset information.\n\t * @since  2.0.0\n\t */\n\tfunction getOffset(el) {\n\t\tel = el.getBoundingClientRect();\n\t\treturn {\n\t\t\tleft: el.left + window.scrollX,\n\t\t\ttop: el.top + window.scrollY\n\t\t}\n\t}\n\n\t/**\n\t * Manually trigger a scroll event.\n\t * @return undefined\n\t * @since 2.0.0\n\t */\n\tfunction triggerScroll() {\n\t\tvar event = new MouseEvent('scroll', {\n\t\t\t'view': window,\n\t\t\t'bubbles': true,\n\t\t\t'cancelable': false\n\t\t});\n\t\twindow.dispatchEvent(event);\n\t}\n\n\t/**!\n\t * Helper function for loading async scripts.\n\t * Load a JS file asynchronously. [c]2014 @scottjehl, Filament Group, Inc. (Based on http://goo.gl/REQGQ by Paul Irish). Licensed MIT\n\t */\n\tfunction loadJS( src, cb ){\n \t\tvar ref      = document.getElementsByTagName( \"script\" )[ 0 ];\n \t\tvar script   = document.createElement( \"script\" );\n \t\tscript.src   = src;\n \t\tscript.async = true;\n \t\tref.parentNode.insertBefore( script, ref );\n \t\tif (cb && typeof(cb) === \"function\") {\n \t\t\tscript.onload = cb;\n \t\t}\n \t\treturn script;\n \t};\n\n})();\n"]}